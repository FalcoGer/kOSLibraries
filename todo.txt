misc scripts:

- hill climbing algorithm
    pass fitness function, calculates fitness for given arguments
    pass arguments as lists with step size list for step size of every argument
    find neighbors
    applies all +/- step sizes on all arguments and those are the neighbors
    fitness function evaluates the neighbors, the best one is returned as the current object of interest unless the current one is the best already
    
    can chain those with decreasing step sizes:
    optimize maneuver for transfer to body
    optimize maneuver for dV (bad score for destroying transfer)
    optimize maneuver for inclination (bad score for destroying transfer)
    optimize maneuver for PA (bad score for destroying transfer or changing inclination much)

aircraft:
- fly to waypoint
- autoland
- set altitude       (pid -> pitch (limit AoA, limit pitchup))
- set heading        (pid -> roll (limit roll angle))
- set speed          (pid -> (lots of) negative means speed brakes?)
- set vertical speed (PID -> pitch (limit AoA, limit pitchup))

maneuver scripts:
orbital:
- circularize, change AP/PA
- inclination change
    including burn to higher orbit for efficiency (hill climbing with 3 nodes (change AP at DN, change inclination at AN, circularize/burn back to original/ignore)?))
	also including actual inclination change not to edit PA
- orbital period change
- do contract orbit (enter arguments from contracts)
- calculate time for fixed dV maneuver with staging
- go to child body, possibly with inclination and pereapsis height


body:
- ascend guidance w/ profile (target speeds, max AoA)
   Have a 2 PID controllers. One of the controllers optimizes pitch for eccentricity over altitude. (1 at launch site or maybe at a given start time (10 seconds after launch))
   The second controller optimizes the throttle for ETA to AP so that it's always 30 seconds on the future.
- descend guidance
- landing descend (PID controller controlling vertical speed (via TWR adjusted for ship tilt)), avoid slopes by follow slopes up or down by pointing towards the slope angle
- surface descend steering: lock steering to lookdirup(up:vector * g + deltaVelocity) where deltaVelocity is locked to desiredVelocity - surfaceVelocity
  this allows together with the vertical speed PID to steer.
- landing w/ coordinates
- time to suicide burn (use fixed dv maneuver time, calculate speed at different heights, equate, solve for height)
- time to impact: d = v0 * t + (a*t^2)/2, solve for t: t = (SQRT(v^2 + 2*g*d) - v) / g     ; where v = initial velocity, g = surface gravity, d = distance to surface.

target:
- intercept target (orbital period change, wait, kill relative)
- intercept target with hohman transfer at best time to meet with target at new AP/PE
- kill relative velocity
- docking: RCS controls, fore, star, top. Translate by vector until lined up. Get fore, star and top components with dot product of unit vector of fore, star and top. (EG fore component of V(5,3,8) is v DOT FORE), see scalar projection. perhaps avoid bounding box.
- match inclination
- match orbit
- time to closest
- Angle to target (orbital angle that the target is ahead of current vessel)


notes:
SMA: Semi Major Axis: Average distance PA and AP from center of body (not sea level), determines orbital period
for transfers and orbit changes, make sure to avoid body encounters
for hill climbing or genetic algorithm aproaches make sure to not crash into a body.
for hill climbing with gravity assist, add maneuver after SOI change back to parent body with 4DOF (time, pro, rad, norm)
hill climbing for maneuvers can be done with CREATEORBIT(pos, vel, body, ut), so nodes need not be created.
  this will however not calculate SOI changes.