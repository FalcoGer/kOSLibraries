misc scripts:

- timewarp to specific time/for specified amount of time
- mission scheduler with event loop

    mission step and events are saved to file so that when craft is unloaded and reloaded or looses power it will resume where it left off without cumbersome checks like status = "Landed"
    
    run_mission(sequence, event_lexicon)
      generates mission lexicon, loads runmode from file if exists and runs the main loop
      while not done {
        sequence[runmode](mission).
        for event in events { events[event](mission). }
      }
    update runmode function to save runmode to file, then update runmode var

- hill climbing algorithm
    pass fitness function, calculates fitness for given arguments
    pass arguments as lists with step size list for step size of every argument
    find neighbors
    applies all +/- step sizes on all arguments and those are the neighbors
    fitness function evaluates the neighbors, the best one is returned as the current object of interest unless the current one is the best already
    
    can chain those with decreasing step sizes:
    optimize maneuver for transfer to body
    optimize maneuver for dV (bad score for destroying transfer)
    optimize maneuver for inclination (bad score for destroying transfer)
    optimize maneuver for PA (bad score for destroying transfer or changing inclination much)

ship scripts:

- calculate DV for stage, including multi engine and mixed engine
- calculate total DV
- get isp of all engines combined for stage
- get total thrust of all engines
- auto deploy/retract solar/comms
- auto deploy/retract gear/lights
- throttle stepping to prevent overshoot: THROTLE = 1 - (current / target * 0.99) (eg current = SHIP:APOAPSIS, target = 100_000e3)

aircraft:
- fly to waypoint
- autoland
- set altitude       (pid -> pitch (limit AoA, limit pitchup))
- set heading        (pid -> roll (limit roll angle))
- set speed          (pid -> (lots of) negative means speed brakes?)
- set vertical speed (PID -> pitch (limit AoA, limit pitchup))

maneuver scripts:
orbital:
- calculate hohman DV
- hohman transfer (change AP, circularize), (burn for DV1 time, burn for DV2 time)
- circularize
- inclination change (including burn to higher orbit for efficiency (hill climbing with 3 nodes (change AP at DN, change inclination at AN, circularize/burn back to original/ignore)?))
- orbital period change
- calculate orbital period: t = 2pi * SQRT(SMA^3 / MU)
- do contract orbit (enter arguments from contracts)
- calculate time for fixed dV maneuver t = g0 * M0 * Isp * (1 - e^(-dV / (g0*Isp))) / F   ; where g0 grav. const, M0 starting mass, F = thrust
- calculate time for fixed dV maneuver with staging
- execue node

body:
- ascend guidance w/ profile (target speeds, max AoA)
   Have a 2 PID controllers. One of the controllers optimizes pitch for eccentricity over altitude. (1 at launch site or maybe at a given start time (10 seconds after launch))
   The second controller optimizes the throttle for ETA to AP so that it's always 30 seconds on the future.
- go to child body, possibly with inclination and pereapsis height
- descend guidance
- landing descend (PID controller controlling vertical speed)
- landing w/ coordinates
- time to suicide burn (use fixed dv maneuver time, calculate speed at different heights, equate, solve for height)
- time to impact: d = v0 * t + (a*t^2)/2, solve for t: t = (SQRT(v^2 + 2*g*d) - v) / g     ; where v = initial velocity, g = surface gravity, d = distance to surface.
- get surface gravity: g = mu / radius^2

target:
- intercept target (orbital period change, wait, kill relative)
- intercept target with hohman transfer at best time to meet with target at new AP/PE
- kill relative velocity
- docking: RCS controls, fore, star, top. Translate by vector until lined up. Get fore, star and top components with dot product of unit vector of fore, star and top. (EG fore component of V(5,3,8) is v DOT FORE), see scalar projection. perhaps avoid bounding box.
- match inclination
- match orbit
- time to closest
- Angle to target (orbital angle that the target is ahead of current vessel)


notes:
SMA: Semi Major Axis: Average distance PA and AP from center of body (not sea level), determines orbital period
for transfers and orbit changes, make sure to avoid body encounters
for hill climbing or genetic algorithm aproaches make sure to not crash into a body.
for hill climbing with gravity assist, add maneuver after SOI change back to parent body with 4DOF (time, pro, rad, norm)
